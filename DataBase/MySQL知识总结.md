# 1. MySQL的基础架构
大体来说，MySQL可以分为Server层和存储引擎层两部分。  
![mysql架构](../imgs/mysql基础架构.png)  
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），
所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。  

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的是InnoDB存储引擎，
它从MySQL5.5.5版本开始成为了默认存储引擎。  

##  连接器
连接器负责跟客户端建立连接、获取权限、维持和管理连接。当输入的用户名密码认证通过后，连接器会到权限表里面查处所拥有的权限。之后这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。  
> 这就意味着，一个用户成功建立连接后，即使使用管理员账号对这个用户的权限做了修改，也不会影响到已经存在连接的权限。修改完成之后，
只有再次新建的连接才会使用新的权限设置。  

连接完成后，如果没有后续的动作，此连接就处于空闲状态。可以在show processlist命令中看到它。  
客户端如果太长时间没有动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认是8小时。  

> 长连接和短连接  
> 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。  
> 短连接则是指每次执行很少的几次查询就断开连接，下次查询再重新建立一个。 

建立连接的过程通常是复杂且耗时的，建议尽量使用长连接。  

但是MySQL在执行过程中临时使用的内存是管理在连接对象里面的，全部使用长连接可能会使MySQL内存占用涨的特别快，OOM之后导致异常重启。  
> 解决方案：  
> 1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存大的查询后，断开连接，之后要查询再重连。  
> 2. MySQL5.7以及以上版本，可以在每次执行一个比较大的操作后，通过msyql_rest_connection来重新初始化连接资源。这个过程不需要重连
和重新做权限认证，但是会将连接状态恢复到刚刚创建完时的状态。  

 # 2. 日志系统
 
 
 # 3. 事务隔离
 SQL标准的隔离级别包括：  
 > 读未提交（read uncommitted），一个事务还没提交时，它做的变更就能够被其别的事务看到。  
 > 读提交（read committed），一个事务提交之后，它做的变更才会被其他事务看到。  
 > 可重复读（repeatable read），一个事务执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。  
 > 串行化（serializable），对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  
 
 在实现上，数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。   
 在“可重复度”隔离级别下，这个视图是在事务启动时创建的，整个事务在期间都用这个视图。  
 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。
 
 Oracle的默认隔离级别是读提交，MySQL的默认隔离级别是可重复度。
 
 # 4. 数据库索引
 ## InnoDB的索引模型 
 在InnoDB中，表都是根据主键顺序以索引形式存放的，这种存储方式的表成为索引组织表。InnoDB使用了B+数索引模型，所以数据都是存在B+树中的。  
 
 每一个索引在InnoDB里面对应一棵B+树。  
 
 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。  
 非主键索引的叶子节点内容是主键的值。在InnoDB里，也被称为二级索引（secondary index）。  
 
 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。  
 
 ## 索引维护
 B+树为了维护索引有序性，在插入新值的时候要做必要的维护。  
 从索引维护谈自增主键和UUID主键。  
 > 自增主键的插入数据模式，符合了递增插入场景。每次插入一条新纪录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。    
 > 而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。  
 > 另外，主键长度越小，普通索引的叶子节点就越小，普通索引占的空间也就越小。
 
 ## 覆盖索引
 现有InnoDB的索引组织结构如下：
 ![索引组织结构](../imgs/index.png)    
 执行以下语句`select * from T where k between 3 and 5;`,需要执行几次树的搜索操作，会扫描多少行？  
> 执行流程如下：  
> 1. 在k索引树上找到k=3的记录，取得ID=300；  
> 2. 再到ID索引树查找ID=300对应的R3；  
> 3. 在k索引树下取下一个值K=5，取得ID=500；  
> 4. 再回到ID索引树查到ID=500对应的R4；  
> 5. 在k索引树取下一个值k=6，不满足条件，循环结束。  
在这个过程中，回到主键索引树搜索的过程，我们成为回表。可以看到，这个查询过程读了k索引树的3条记录（1，3，5），回表了两次（2，4）。  

如果执行的语句是`select ID from T where k between 3 and 5`，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，
不需要回表。也就是说，这个查询里面，索引k“覆盖了”我们的查询需求，我们成为覆盖索引。  
> 由于覆盖索引可与i减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。


 
 
